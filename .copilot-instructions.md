# Copilot Instructions for Attendr Project

## Project Overview

Attendr is a conference management platform that enables attendees to:
- Mark sessions as favorites
- Navigate through conferences conveniently
- Participate in groups and view activities of other group members

The project is built with .NET and is organized as a microservice architecture with the following key components:
- **Conferences Service**: Manages conference data and sessions
- **Groups Service**: Handles group management and member activities
- **Profiles Service**: Manages attendee profiles

## Guidelines and Documentation

### Always Consult Design Guidelines

Before making any code changes, architectural decisions, or implementing new features:
- **Consult the hexmaster-design-guidelines MCP** for code guidelines, patterns, and architectural recommendations
- Follow the established patterns and best practices documented in the design guidelines

### Always Consult Microsoft Documentation

For all .NET, C#, Azure, and related technology questions:
- **Consult the microsoft.docs MCP** for official documentation, API references, and best practices
- Ensure implementations align with current Microsoft standards and recommendations

### Documentation Location

All documentation for the Attendr project should be stored in the **/docs** folder at the root of the repository. This includes:
- Architecture documentation
- API specifications
- Development guides
- Deployment instructions
- Design decisions and ADRs (Architecture Decision Records)

## Change Process Requirements

**Before applying ANY changes to the codebase, you MUST present the following:**

### 1. Assumptions
List all assumptions you are making about:
- The current implementation and architecture
- User intent and requirements
- Existing dependencies and configurations
- System behavior and constraints

### 2. Assessments
Provide an assessment of:
- The scope of the required changes
- Impact on existing code and functionality
- Potential risks or breaking changes
- Performance implications
- Testing requirements

### 3. Tasks
Break down the work into concrete tasks:
- A numbered list of specific implementation steps
- File changes required
- Tests or validation needed
- Documentation updates if applicable

## Project Structure and Architecture

### Overview of the Codebase

The Attendr project follows a **microservices architecture** with a layered, domain-driven design. The solution is organized in the `/src` folder with the following structure:

#### Service Domains

1. **Conferences Service** (`/src/Conferences`)
   - **Purpose**: Manages conference data, sessions, schedules, and related information
   - **Data Store**: MongoDB
   - **Projects**:
     - `HexMaster.Attendr.Conferences`: Domain logic and business rules
     - `HexMaster.Attendr.Conferences.Abstractions`: Interfaces and contracts
     - `HexMaster.Attendr.Conferences.Api`: ASP.NET Core Web API (OpenAPI/Swagger enabled)
     - `HexMaster.Attendr.Conferences.Data.MongoDb`: MongoDB data access layer
     - `HexMaster.Attendr.Conferences.Tests`: Unit tests

2. **Groups Service** (`/src/Grops` and `/src/Groups`)
   - **Purpose**: Manages group creation, membership, and group activities
   - **Data Store**: Azure Table Storage
   - **Projects**:
     - `HexMaster.Attendr.Groups`: Domain logic and business rules
     - `HexMaster.Attendr.Groups.Abstractions`: Interfaces and contracts
     - `HexMaster.Attendr.Groups.Api`: ASP.NET Core Web API (OpenAPI/Swagger enabled)
     - `HexMaster.Attendr.Groups.Data.TableStorage`: Azure Table Storage data access layer
     - `HexMaster.Attendr.Groups.Tests`: Unit tests

3. **Profiles Service** (`/src/Profiles`)
   - **Purpose**: Manages attendee profiles and personal information
   - **Data Store**: Azure Table Storage
   - **Projects**:
     - `HexMaster.Attendr.Profiles`: Domain logic and business rules
     - `HexMaster.Attendr.Profiles.Abstractions`: Interfaces and contracts
     - `HexMaster.Attendr.Profiles.Api`: ASP.NET Core Web API (OpenAPI/Swagger enabled)
     - `HexMaster.Attendr.Profiles.Data.TableStorage`: Azure Table Storage data access layer
     - `HexMaster.Attendr.Profiles.Tests`: Unit tests

4. **Shared Core** (`/src/Shared/HexMaster.Attendr.Core`)
   - **Purpose**: Contains shared utilities, common interfaces, and cross-cutting concerns
   - **Usage**: Referenced by all service domains

5. **Front-end Application** (`/src/App`)
   - **Purpose**: Angular-based web application providing the user interface for the Attendr platform
   - **Framework**: Angular 21 (zoneless mode with routing and standalone components)
   - **Component Library**: PrimeNG (Prime Faces)
   - **Key Features**:
     - Zoneless change detection for improved performance
     - Standalone components architecture (no NgModules)
     - Integrated routing
     - Modern component-based UI with PrimeNG components
   - **Structure**:
     - `src/app/`: Main application source code
     - `public/`: Static assets
     - `angular.json`: Angular workspace configuration
     - `package.json`: npm dependencies and scripts
     - TypeScript configuration files for different build scenarios

### Architectural Patterns

- **Clean Architecture**: Each service follows separation of concerns with distinct layers
- **Abstractions**: Abstractions projects define contracts and interfaces for decoupling
- **API Layer**: Built with ASP.NET Core, featuring OpenAPI/Swagger documentation
- **Data Access**: Repository pattern with specialized implementations for each data store:
  - MongoDB for Conferences (scalability for session/schedule data)
  - Azure Table Storage for Groups and Profiles (cost-effective for relational-like data)
- **Testing**: Unit test projects for each service domain
- **Front-end Architecture**: 
  - Angular 21 with zoneless change detection for optimal performance
  - Standalone components pattern (no NgModules) for better tree-shaking and modularity
  - PrimeNG component library for consistent, enterprise-grade UI components
  - Reactive programming patterns with RxJS
  - Modern TypeScript with strict type checking

### Current State Assessment

**Status**: The project is in early development with foundational structure in place.

**Observations**:
- Service domains are properly separated with clear boundaries
- API projects are created but contain placeholder WeatherForecast endpoints
- Abstractions layers are defined, indicating intentional separation of concerns
- Data access layers are configured for their respective data stores
- Core shared library exists for common functionality
- Test projects are present but likely need implementation

**Areas for Development**:
- Domain logic implementation in core projects
- API endpoint implementation (move beyond placeholder weather endpoints)
- Data access layer implementation for business entities
- Integration with actual data stores
- Comprehensive test coverage
- Cross-service communication and resilience patterns
- Authentication and authorization mechanisms
- API documentation and examples

### Standard Way of Working

When working on this project, follow these principles:

1. **Domain Organization**: Changes should align with the microservice domains (Conferences, Groups, Profiles)
2. **Layered Approach**: Implement changes across the appropriate layers (Domain → Abstractions → API → Data Access)
3. **Consistency**: Each service domain should follow the same structural patterns as established in the project
4. **Testing**: Accompany code changes with corresponding unit tests
5. **Documentation**: Document significant architectural decisions in the `/docs` folder
6. **Abstractions First**: Define interfaces in Abstractions projects before implementing
7. **Data Store Alignment**: 
   - Use MongoDB patterns for Conferences service
   - Use Azure Table Storage patterns for Groups and Profiles services
   - Reference the Shared/Core library for common utilities
8. **Front-end Development**:
   - Use standalone Angular components (avoid NgModules)
   - Leverage PrimeNG components for UI elements
   - Follow Angular 21 best practices including zoneless change detection patterns
   - Implement reactive patterns with RxJS for data management
   - Ensure TypeScript strict mode compliance
   - Use Angular Router for navigation
   - Follow component-based architecture with clear separation of concerns

